
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6. Soccer Client &#8212; The RoboCup Soccer Simulator  documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Coach" href="coach.html" />
    <link rel="prev" title="5. Soccer Monitor" href="soccermonitor.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="coach.html" title="7. Coach"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="soccermonitor.html" title="5. Soccer Monitor"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The RoboCup Soccer Simulator  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Soccer Client</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="soccer-client">
<h1><span class="section-number">6. </span>Soccer Client<a class="headerlink" href="#soccer-client" title="Permalink to this headline">¶</a></h1>
<div class="section" id="protocols">
<h2><span class="section-number">6.1. </span>Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h2>
<p>This section provides a brief overview of the protocol between the Soccer Client and the
Soccer Server. More details on these protocols can be found in the Soccer Server section.
Note that the init and reconnect commands should be send to the player’s UDP port
(default: 6000) of the Soccer Server machine, and after the response they should be sent
to the port assigned to your player by the server, in a valid format. The server sends
the init response from this port (refer to section 1.2.1) . All the commands sent to or
received from the server are strings of common character and are in a pair of parenthesis.</p>
<div class="section" id="initialization-and-reconnection">
<h3><span class="section-number">6.1.1. </span>Initialization and Reconnection<a class="headerlink" href="#initialization-and-reconnection" title="Permalink to this headline">¶</a></h3>
<p>Every player wanting to connect to the server should introduce himself. This is like a
handshake and is done only at the beginning and optionally in the half time when you
want to reconnect.</p>
<div class="section" id="initialization">
<h4>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h4>
<p>Your client should send an init command to the server in the following format</p>
<blockquote>
<div><p>(init <em>TeamName</em> [(version <em>VerNum</em>)] [(goalie)])</p>
</div></blockquote>
<p>The goalie should include the ”(goalie)” in the init command to be allowed by the
server to catch the ball or do another special goalie action. Note there can only be one
or no goalie in each team. (You are not obliged to use a goalie)
The Server welcomes you with a response to your init message in the following format</p>
<blockquote>
<div><p>(init <em>Side</em> <em>UniformNumber</em> <em>PlayMode</em>)</p>
</div></blockquote>
<p>Or by an error message (if there is an error, i.e. you have initiated more than two
team, more than 11 players in a team or more than one goalie in a team)</p>
<blockquote>
<div><p>(error no_more_team_or_player_or_goalie)</p>
</div></blockquote>
<p>Side is your team’s side of play, a character, l(left) or r(right). UniformNumber is the
player’s uniform number (the players of each team are known by their uniform number).
PlayMode is a string representing one of the valid play modes.</p>
<p>If you connect to server with versions 7.00 or higher you will receive additional server
parameters, player parameters and player types information ( the last two are related
to the hetero players feature ). For the exact format refer to the appendix.</p>
<blockquote>
<div><p>(server_param <em>Parameters</em> … )</p>
<p>(player_param <em>Parameters</em> … )</p>
<p>(player_type <em>id</em> <em>Parameters</em> … )</p>
</div></blockquote>
<p>Here the hand shaking is finished and your client is known as a valid player.</p>
</div>
<div class="section" id="reconnection">
<h4>Reconnection<a class="headerlink" href="#reconnection" title="Permalink to this headline">¶</a></h4>
<p>Reconnection is useful for changing the client program of a player without restarting the
game. It can only be done in a non-PlayOn playing mode (e.g. in the half time).
For reconnection you should send a reconnect command in the following format</p>
<blockquote>
<div><p>(reconnect <em>TeamName</em> <em>UniformNumber</em>)</p>
</div></blockquote>
<p>And you will receive a response in the following format</p>
<blockquote>
<div><p>(reconnect <em>Side</em> <em>PlayMode</em>)</p>
</div></blockquote>
<p>Or one of the following errors</p>
<blockquote>
<div><p>(can’t reconnect)</p>
</div></blockquote>
<p>if the game is in the PlayOn mode.</p>
<blockquote>
<div><p>(error reconnect)</p>
</div></blockquote>
<p>when no client reconnected due to an error. You may also receive the following error
if the team name is invalid <strong>(error no_more_team_or_player_or_goalie)</strong>
Here again if you are connecting to the server with version 7.00 or higher you will
receive additional server parameters, player parameters and player types information.</p>
</div>
<div class="section" id="disconnection">
<h4>Disconnection<a class="headerlink" href="#disconnection" title="Permalink to this headline">¶</a></h4>
<p>Before you disconnect, you can send a bye command to the server. This command will
remove the player from the field.</p>
<blockquote>
<div><p>(bye)</p>
</div></blockquote>
<p>There will be no answers from the server.</p>
</div>
<div class="section" id="version-control">
<h4>Version Control<a class="headerlink" href="#version-control" title="Permalink to this headline">¶</a></h4>
<p>Due to the progressive development of the Soccer Server, new features have been added
every year and this resulted in changes and improvements in the protocols to support
these features. In order to keep compatibility with the older clients and making it easier
to work with (specially for researchers), a system has been implemented for the Protocols
Version Control. Every client should tell the server the version of its communication
protocol in the <strong>init</strong> command so that the server would be able to send the messages in
the proper format.
But note that although the communication protocol remains unchanged, the judgment
and the simulation rules may change and this will affect the whole game.</p>
</div>
</div>
<div class="section" id="control-commands">
<h3><span class="section-number">6.1.2. </span>Control Commands<a class="headerlink" href="#control-commands" title="Permalink to this headline">¶</a></h3>
<p>During the game each player can send action commands. The server executes the commands at the end of the cycle and simulates the next cycle regarding the received commands and the previous cycles data.</p>
<div class="section" id="body-commands">
<h4>Body Commands<a class="headerlink" href="#body-commands" title="Permalink to this headline">¶</a></h4>
<p>All the playing and movement behaviors of the player are consisted from a few commands
known as body commands that are presented briefly below.
The results of these commands are a little complicated and depend on many simulation
factors. For the details of the execution of each command refer to the Soccer Server
Section.</p>
<blockquote>
<div><p>(turn <em>Moment</em>)</p>
</div></blockquote>
<p>The Moment is in degrees from −180 to 180. This command will turn the
player’s body direction Moment degrees relative to the current direction.</p>
<blockquote>
<div><p>(dash <em>Power</em>)</p>
</div></blockquote>
<p>This command accelerates the player in the direction of its body (not direction of the current speed). The Power is between <strong>minpower</strong> (used value:
−100) and <strong>maxpower</strong> (used value: 100).</p>
<blockquote>
<div><p>(kick <em>Power Direction</em>)</p>
</div></blockquote>
<p>Accelerates the ball with the given Power in the given Direction. The direction is relative to the the Direction of the body of the player and the power
is again between <strong>minpower</strong> and <strong>maxparam</strong>.</p>
<blockquote>
<div><p>(catch <em>Direction</em>)</p>
</div></blockquote>
<p>Goalie special command: Tries to catch the ball in the given Direction relative
to its body direction. If the catch is successful the ball will be in the goalie’s
hand until kicked away.</p>
<blockquote>
<div><p>(move <em>X</em> <em>Y</em>)</p>
</div></blockquote>
<p>This command can be executed only before kick off and after a goal. It
moves the player to the exact position of X (between −54 and 54) and Y
(between −32 and 32) in one simulation cycle. This is useful for before kick
off arrangements.</p>
<p>Note that in each simulation cycle, only one of the above five commands can be
executed (i.e. if the client sends more than one command in a single cycle, one of them
will be executed randomly, usually the one received first)</p>
<blockquote>
<div><p>(turn_neck <em>Angle</em>)</p>
</div></blockquote>
<p>This command can be sent (and will be executed) each cycle independently, along with
other action commands. The neck will rotate with the given Angle relative to previous
Angle. Note that the resulting neck angle will be between <strong>minneckang</strong> (default: −90)
and <strong>maxneckang</strong> (default: 90) relative to the player’s body direction.</p>
</div>
<div class="section" id="communication-commands">
<h4>Communication Commands<a class="headerlink" href="#communication-commands" title="Permalink to this headline">¶</a></h4>
<p>The only way of communication between two players is broadcasting of messages through
the <strong>say</strong> command and hearing through the <strong>hear</strong> sensor.</p>
<blockquote>
<div><p>(say <em>Message</em>)</p>
</div></blockquote>
<p>This command broadcasts the Message through the field, and any player near enough
(specified with <strong>audio_cut_dist</strong>, default: 50.0 meters), with enough hearing capacity will
hear the Message. The message is a string of valid characters.</p>
<blockquote>
<div><p>(ok say)</p>
</div></blockquote>
<p>Command succeeded.
In case of error there will be the following response from the Server</p>
<blockquote>
<div><p>(error illegal_command_form)</p>
</div></blockquote>
</div>
<div class="section" id="misc-commands">
<h4>Misc. Commands<a class="headerlink" href="#misc-commands" title="Permalink to this headline">¶</a></h4>
<p>Other commands are usually of two forms:</p>
<ul>
<li><p>Data Request Commands</p>
<p>(sense_body)</p>
<p>Requests the server to send sense body information. Note the server sends sense
body information every cycle if you connect with version 6.00 or higher.</p>
<p>(score)</p>
<p>Request the server to send score information. The server’s reply will be in this
format</p>
<p>(score <em>Time</em> <em>OurScore</em> <em>OpponentScore</em>)</p>
</li>
<li><p>Mode Change Commands</p>
<p>(change_view <em>Width</em> <em>Quality</em>)</p>
<p>Changes the view parameters of the player. Width is one of narrow, normal or
wide and Quality is one of high or low. The amount and detail of the information
returned by the visual sensor depends on the width of the view and the quality. But
note that the frequency of sending information also depends on these parameters
(e.g. if you change the quality from high to low, the frequency doubles, and the
time between two see sensors will be cut to half).</p>
</li>
</ul>
</div>
</div>
<div class="section" id="sensor-information">
<h3><span class="section-number">6.1.3. </span>Sensor Information<a class="headerlink" href="#sensor-information" title="Permalink to this headline">¶</a></h3>
<p>Sensor information are the messages that are sent to all players regularly (e.g. each cycle
or each one and half a cycle). There is no need to send any message to the server to get
these information.
All the returned information of the sensors have a time label, indication the cycle
number of the game when the data have been sent (indicated by Time). This time is
very useful.</p>
<div class="section" id="visual-sensor">
<h4>Visual Sensor<a class="headerlink" href="#visual-sensor" title="Permalink to this headline">¶</a></h4>
<p>Visual Sensor is the most important sensor, and is a little bit complicated. This sensor
returns information about the objects that can be seen from the player’s view (i.e.
objects that are in the view angle and not very far).</p>
<blockquote>
<div><p>The main format of the information is</p>
<blockquote>
<div><p>(see <em>Time</em> <em>ObjInfo</em> <em>ObjInfo</em> … )</p>
</div></blockquote>
<p>The ObjInfos are of the format below</p>
<blockquote>
<div><p>(<em>ObjName</em> <em>Distance</em> <em>Direction</em> [<em>DistChange</em> <em>DirChange</em> [<em>BodyFacingDir</em> <em>HeadFacingDir</em>]])</p>
</div></blockquote>
</div></blockquote>
<p>or</p>
<blockquote>
<div><p>(<em>ObjName</em> <em>Direction</em>)</p>
</div></blockquote>
<p>Note that the amount of information returned for each object depends on its distance. The more distant the object is the less information you get. For more detailed
information regarding ObjInfo refer to Appendix.</p>
<blockquote>
<div><p>ObjName is in one of the following formats:</p>
<blockquote>
<div><p>(p [<em>TeamName</em> [<em>Unum</em>]])</p>
<p>(b )</p>
<p>(f <em>FlagInfo</em>)</p>
<p>(g <em>Side</em>)</p>
</div></blockquote>
<p><strong>p</strong> stands for player, <strong>b</strong> stands for ball, <strong>f</strong> stands for flag and <strong>g</strong> stands for goal.
Side is one of <strong>l</strong> for left or <strong>r</strong> for right. For more information on FlagInfo refer to</p>
</div></blockquote>
<p>Appendix.</p>
</div>
<div class="section" id="audio-sensor">
<h4>Audio Sensor<a class="headerlink" href="#audio-sensor" title="Permalink to this headline">¶</a></h4>
<p>Audio sensor returns the messages that can be heard through the field. They may come
from the online coach, referee, or other players.</p>
<blockquote>
<div><p>The format is as follows:</p>
<blockquote>
<div><p>(hear <em>Time</em> <em>Sender</em> <em>Message</em>)</p>
</div></blockquote>
<p>Sender is one of the followings:
<strong>self</strong>: when the sender is yourself.
<strong>referee</strong>: when the sender is the referee of the game.
<strong>online_coach_l</strong> or <strong>online_coach_r</strong>
Direction: when the sender is a player other than yourself the relative direction of the</p>
</div></blockquote>
<p>sender is returned instead.</p>
</div>
<div class="section" id="body-sensor">
<h4>Body Sensor<a class="headerlink" href="#body-sensor" title="Permalink to this headline">¶</a></h4>
<p>Body sensor returns all the states of the player such as remaining stamina, view mode
and the speed of the player at the beginning of each cycle:</p>
<blockquote>
<div><blockquote>
<div><p>(sense_body <em>Time</em> (view_mode { high | low } { narrow | normal |
wide }) (stamina <em>Stamina</em> <em>Effort</em>) (speed <em>Speed</em> <em>Angle</em>) (head_angle
<em>Angle</em>) (kick <em>Count</em>) (dash <em>Count</em>) (turn <em>Count</em>) (say <em>Count</em>)
(turn_neck <em>Count</em>) (catch <em>Count</em>) (move <em>Count</em>) (change_view
<em>Count</em>))</p>
</div></blockquote>
<p>The last eight parameters are counters of the received commands. Use the counters
to keep track of lost or delayed messages.</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="how-to-create-clients">
<h2><span class="section-number">6.2. </span>How to Create Clients<a class="headerlink" href="#how-to-create-clients" title="Permalink to this headline">¶</a></h2>
<p>This section provides a brief description to write a first-step program of soccer client.</p>
<div class="section" id="sample-client">
<h3><span class="section-number">6.2.1. </span>Sample Client<a class="headerlink" href="#sample-client" title="Permalink to this headline">¶</a></h3>
<p>The Soccer Server distribution includes a very simple program for soccer clients, called
sampleclient. It is under the ”sampleclient” directory of the distribution, and is
automatically compiled when you make the Soccer Server.
The sampleclient is not a stand-alone client: It is a simple ‘pipe’ that redirects
commands from its standard input to the server, and information from the server to its
standard output. Therefore, nothing happens when users invoke the sampleclient. The
users must type-in commands from keyboards, and read the sensor information displayed
on the terminal. (Actually it is impossible to read sensor information, because the server
sends about 17 sensor informations (see information and sense_body information) per
second.)
The sampleclient is useful to understand what clients should do, and what the clients
will receive from the server.</p>
<p><strong>How to Use</strong> sampleclient
Here is a typical usage of the sampleclient.</p>
<blockquote>
<div><ol class="arabic">
<li><p>Invoke client under sampleclient directory of the Soccer Server.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="o">./</span><span class="n">client</span> <span class="n">SERVERHOST</span>
</pre></div>
</div>
<p>Here, SERVERHOST is a hostname on which Soccer Server is running.
Then the program awaits user input.
If the Soccer Server uses an unusual port, for example 6005, instead of the standard
port (6000), the users should use the following form.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="o">./</span><span class="n">client</span> <span class="n">SERVERHOST</span> <span class="mi">6005</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Type in init command from the keyboard.</p>
<blockquote>
<div><p>(init MYTEAMNAME (version 7))</p>
<p>Here MYTEAMNAME is a team name the users want to use.
Then a player appears on the field. In the same time, the program starts to
output the sensor information sent from the server to the terminal. Here is a
typical output</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">send</span> <span class="mi">6000</span> <span class="p">:</span> <span class="p">(</span><span class="n">init</span> <span class="n">foo</span> <span class="p">(</span><span class="n">version</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">init</span> <span class="n">r</span> <span class="mi">1</span> <span class="n">before_kick_off</span><span class="p">)</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">server_param</span> <span class="mf">14.02</span> <span class="mi">5</span> <span class="mf">0.3</span> <span class="mf">0.4</span> <span class="mf">0.1</span> <span class="mi">60</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">4000</span> <span class="mi">45</span> <span class="mi">0</span> <span class="mf">0.3</span> <span class="mf">0.5</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_param</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="o">-</span><span class="mi">100</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="mi">25</span> <span class="mi">0</span> <span class="mf">0.002</span> <span class="o">-</span><span class="mi">100</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">45</span> <span class="mf">0.4</span> <span class="mi">5</span> <span class="mf">0.006</span> <span class="mf">0.3</span> <span class="mf">0.7</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mf">0.6</span><span class="p">)</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">1</span> <span class="mf">1.16432</span> <span class="mf">28.5679</span> <span class="mf">0.533438</span> <span class="mf">8.33595</span> <span class="mf">0.00733326</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">2</span> <span class="mf">1.19861</span> <span class="mf">25.1387</span> <span class="mf">0.437196</span> <span class="mf">5.92991</span> <span class="mf">0.00717675</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">3</span> <span class="mf">1.04904</span> <span class="mf">40.0956</span> <span class="mf">0.436023</span> <span class="mf">5.90057</span> <span class="mf">0.00631769</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">4</span> <span class="mf">1.1723</span> <span class="mf">27.7704</span> <span class="mf">0.568306</span> <span class="mf">9.20764</span> <span class="mf">0.00746072</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">5</span> <span class="mf">1.12561</span> <span class="mf">32.4392</span> <span class="mf">0.402203</span> <span class="mf">5.05509</span> <span class="mf">0.00621539</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">player_type</span> <span class="mi">6</span> <span class="mf">1.02919</span> <span class="mf">42.0812</span> <span class="mf">0.581564</span> <span class="mf">9.53909</span> <span class="mf">0.00688457</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">sense_body</span> <span class="mi">0</span> <span class="p">(</span><span class="n">view_mode</span> <span class="n">high</span> <span class="n">normal</span><span class="p">)</span> <span class="p">(</span><span class="n">stamina</span> <span class="mi">4000</span> <span class="mi">1</span><span class="p">)</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">see</span> <span class="mi">0</span> <span class="p">((</span><span class="n">g</span> <span class="n">r</span><span class="p">)</span> <span class="mf">61.6</span> <span class="mi">37</span><span class="p">)</span> <span class="p">((</span><span class="n">f</span> <span class="n">r</span> <span class="n">t</span><span class="p">)</span> <span class="mf">49.4</span> <span class="mi">3</span><span class="p">)</span> <span class="p">((</span><span class="n">f</span> <span class="n">p</span> <span class="n">r</span> <span class="n">t</span><span class="p">)</span> <span class="mi">37</span> <span class="mi">27</span><span class="p">)</span> <span class="o">...</span>
<span class="n">recv</span> <span class="mi">1567</span> <span class="p">:</span> <span class="p">(</span><span class="n">sense_body</span> <span class="mi">0</span> <span class="p">(</span><span class="n">view_mode</span> <span class="n">high</span> <span class="n">normal</span><span class="p">)</span> <span class="p">(</span><span class="n">stamina</span> <span class="mi">4000</span> <span class="mi">1</span><span class="p">)</span> <span class="o">...</span>
</pre></div>
</div>
<p>The first line, “send 6000 : (init foo (version 7))”, is a report what
the client sends to the server. The second line,”recv 1567 : (init r 1
before_kick_off) is a report of the first response from the server. Here, the
server tells the client that the assigned player is the right side team (r), its uniform number is 1, and the current playmode is before_kick_off. The next 9
lines are server_param and player_param, which tells various parameters used in
the simulation. Finally, the server starts to send the normal sensor informations,
sense_body and see. Because the server sends these sensor information every
100ms or 150ms, the client continues to output the information endlessly.</p>
</div></blockquote>
</li>
<li><dl>
<dt>Type in move command to place the player to the initial position. The player</dt><dd><p>appears on a bench outside of the field. Users need to move it to its initial position
by move command like:</p>
<blockquote>
<div><p>(move -10 10)</p>
</div></blockquote>
<p>Then the player moves to the point (-10,10).
Because, as mentioned before, the client program outputs sensor information
endlessly, users can not see strings they type in. So, they must type-in commands
blindly. <a class="footnote-reference brackets" href="#f1" id="id1">1</a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Click ‘Kick-Off’ button on the Soccer Server. Then the game starts. The users</dt><dd><p>can see that the time data in each sensor information (the first number of see and
sense_body information) are increasing.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>After then, users can use any normal command, turn, dash, kick and so on. For</dt><dd><p>example, users can turn the player to the right by typing:</p>
<blockquote>
<div><p>(turn 90)</p>
</div></blockquote>
<p>The player can dash forward with full power by typing:</p>
<blockquote>
<div><p>(dash 100)</p>
</div></blockquote>
<p>When the player is near enough to the ball, it can kick the ball to the left with
power 50 by:</p>
<blockquote>
<div><p>(kick 50 -90)</p>
</div></blockquote>
<p>Note again that because of endless sensor output, users must type-in these commands blindly.</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<div class="section" id="overall-structure-of-sample-client">
<h4>Overall Structure of Sample Client<a class="headerlink" href="#overall-structure-of-sample-client" title="Permalink to this headline">¶</a></h4>
<p>The structure of the sampleclient is simple. The brief process the client does is as
follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Open a UDP socket and connect to the server port. (init_connection())</p></li>
<li><p>Enter the read-write loop (message_loop), in which the following two processes are executed in parallel.</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>read user’s input from the standard input (usually a keyboard) and send it
to the server (send_message()).</p></li>
<li><p>receive the sensor information from the server (receive_message()) and output it to the standard output (usually a console).</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p>In order to realize the parallel execution, sampleclient uses the select() function.
The function enables to wait for multiple input from sockets and streams in a single
process. When select() is called, it waits until one of the sockets and streams gets
input data, and tells which sockets or streams got the data. For more details of the
usage of select(), please refer to the man page or manual documents.</p>
<p>An important tip in the sampleclient is that the client must change the server’s port
number when it receives sensor informations from the server. This is because the server
assign a new port to a client when it receives an init command. This is done by the
following statement in ”client.c” (around line 147)</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>printf( &quot;recv %d : &quot;, ntohs(serv_addr.sin_port));
sock-&gt;serv_addr.sin_port = serv_addr.sin_port ;
buf[n] = ’\0’
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="simple-clients">
<h3><span class="section-number">6.2.2. </span>Simple Clients<a class="headerlink" href="#simple-clients" title="Permalink to this headline">¶</a></h3>
<p>In order to develop complete soccer clients, what users must do is to write code of a
‘brain’ part, which performs the same thing as users do with the sampleclient described
in the previous section. In other words, users must write a code to generate command
strings to send to the server based on received sensor information.</p>
<p>Of course it is not a simple task (so that many researchers tackle RoboCup as a
research issue), and there are various ways to implement it. Simply saying, in order to
develop player clients, users need to realize the following functions</p>
<p><strong>[Sensing]</strong> To analyze sensor information: As shown in the previous section, the server
sends various sensor information in S-expressions. Therefore, a client needs to
parse the S-expressions. Then, the client must analyze the information to get a
certain internal representation. For example, the client needs to analyze a visual
information to estimate player’s location and field status, because the visual information only include relative locations of landmarks and moving objects on the
field.</p>
<p><strong>[Action Interval]</strong> To control interval of sending commands: Because the server accepts
a body command (turn, dash and kick) per 100ms, the client needs to wait appropriate interval before sending a command.</p>
<p><strong>[Parallelism]</strong> To execute sensor and action processes in parallel: Because the Soccer
Server processes sensor information and command asynchronously, clients need
to execute a sensor process, which deals with sensor information, and an action
process, which controls to send commands, in parallel.</p>
<p><strong>[Planning]</strong> To make a plan of play: Using sensor information, the client needs to generate appropriate command sequences of play. Of course, this is the final goal of developing soccer clients!!</p>
<p>Here are two simple examples of stand-alone players, sclient1 and sclient2, which
just chase the ball and kick it to the opponent goal. The sources are available from</p>
<blockquote>
<div><p><a class="reference external" href="ftp://ci.etl.go.jp/pub/soccer/client/noda-client-2.0.tar.gz">ftp://ci.etl.go.jp/pub/soccer/client/noda-client-2.0.tar.gz</a></p>
</div></blockquote>
<p>In the examples, the functions listed above are realized as follows:</p>
<blockquote>
<div><ul>
<li><p>For Sensing function, both examples use common facilities of class BasePlayer,
class FieldState, and estimatePos functions. By these facilities, the example
programs do:</p>
<blockquote>
<div><ul class="simple">
<li><p>receive data from a socket connected with the server,</p></li>
<li><p>parse the data as S-expression,</p></li>
<li><p>interpret the expression into internal data format (class SensorInfo),</p></li>
<li><p>and in the case the received data is visual sensor information, estimate player’s
and other object’s positions.</p></li>
</ul>
</div></blockquote>
<p>For more detail, please read the source code.</p>
</li>
<li><p>For Action Interval and Parallelism functions, the two examples use different methods. The first example, sclient1 uses timeout of select() function. The second
one, sclient2 uses the multi-thread (pthread) facility. These are described below.</p></li>
<li><dl class="simple">
<dt>For Planning function, both examples have very simple planners as follows:</dt><dd><ul class="simple">
<li><p>If the player does not see the ball in recent 10 steps, or if the player can not
estimate its position in recent 10 steps, it looks around.</p></li>
<li><p>If the ball is in kickable area, it kicks the ball to the opponent goal.</p></li>
<li><p>Otherwise, the player rushes to the ball (turns to the ball and dashes).</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>sclient1</p>
<p>The sclient1 uses the timeout facility of select() function to realize Action Interval
and Parallelism.</p>
<p>The key part of the program is in MyPlayer::run(). Here is the part of the source
code</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//----------------------------------------</span>
<span class="c1">// enter main loop</span>

<span class="n">SocketReadSelector</span> <span class="n">selector</span> <span class="p">;</span>

<span class="n">TimeVal</span> <span class="n">nexttic</span> <span class="p">;</span> <span class="c1">// indicate the timestamp for next command send</span>
<span class="n">nexttic</span><span class="p">.</span><span class="n">update</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// set nexttic to the current time.</span>

<span class="k">while</span><span class="p">(</span><span class="n">True</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//-------------------------------------------------</span>
    <span class="c1">// setup selector</span>

    <span class="n">selector</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span> <span class="p">;</span>
    <span class="n">selector</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">//-------------------------------------------------</span>
    <span class="c1">// wait socket input or timeout (100ms) ;</span>

    <span class="n">Int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">selector</span><span class="p">.</span><span class="n">selectUntil</span><span class="p">(</span><span class="n">nexttic</span><span class="p">)</span> <span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// in the of timeout. (no sensor input)</span>
        <span class="n">doAction</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// enter action part</span>
        <span class="n">nexttic</span> <span class="o">+=</span> <span class="n">TimeVal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// increase nexttimetic 100ms</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// got some input</span>
        <span class="n">doSensing</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// enter sensor part</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Here, class SocketReadSelector is a class to abstract facilities of select() and is
defined in ”itk/Socket.h”. In the line “Int r = selector.selectUntil(nexttic)
;”, the program awaits the socket input or timeout indicated by nexttic, which holds
the timestamp of the next tic (simulation step). The function returns 0 if timeout, or
the number of receiving sockets. In the case of timeout, the program calls doAction() in
which a command is generated and sent to the server, or otherwise, it calls doSensing()
in which a sensor information is processed.</p>
<p>sclient2</p>
<p>The sclient2 uses the POSIX thread (pthread) facilities to realize Action Interval and
Parallelism.</p>
<p>The key part of the program is also in MyPlayer::run(). Here is the part of the
source code:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//----------------------------------------</span>
<span class="c1">// fork sensor thread</span>

<span class="n">forkSensor</span><span class="p">()</span> <span class="p">;</span>

<span class="c1">//----------------------------------------</span>
<span class="c1">// main loop</span>

<span class="k">while</span><span class="p">(</span><span class="n">True</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isBallSeenRecently</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">//------------------------------</span>
        <span class="c1">// if ball is not seen recently</span>
        <span class="c1">// look around by (turn 60)</span>
        <span class="k">for</span><span class="p">(</span><span class="n">UInt</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">turn</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span> <span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">kickable</span><span class="p">())</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The statement “forkSensor() ;” invokes a new thread for receiving and analyzing the
sensor information. (The behavior of the sensor thread are defined in ”SimpleClient.*”
and ”ThreadedClient.*”.) Then the main thread enters the main loop in which action
sequences of “chasing the ball and kick to the goal” are generated. Because Sensing
function is handled in the sensor thread in parallel, the main thread needs not take care
of the sensor input.</p>
<p>In order to keep action interval to be 100ms, the sclient2 waits for the next
simulation step by the function ThreadedPlayer::sendCommandPre() defined in
”ThreadedPlayer.cc” as follows:</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Bool</span> <span class="n">ThreadedPlayer</span><span class="o">::</span><span class="n">sendCommandPre</span><span class="p">(</span><span class="n">Bool</span> <span class="n">bodyp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cvSend</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span> <span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">bodyp</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">nextSendBodyTime</span><span class="p">.</span><span class="n">isFuture</span><span class="p">())</span>
            <span class="n">cvSend</span><span class="p">.</span><span class="n">waitUntil</span><span class="p">(</span><span class="n">nextSendBodyTime</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">nextSendTime</span><span class="p">.</span><span class="n">isFuture</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">cvSend</span><span class="p">.</span><span class="n">waitUntil</span><span class="p">(</span><span class="n">nextSendTime</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">True</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>In this function, MutexCondVar cvSend provide a similar timeout facility of select()
function used in sclient1 described above. (MutexCondVar is a combination of
condition variable (pthread_cond_t) and mutex (<a href="#id2"><span class="problematic" id="id3">pthread_mutex_</span></a> ), and is defined in
”itk/MutexCondVar.h”.) Because the function is called just before the player sends a
command to the server, and nextSendBodyTime is controlled to indicate the timestamp
of the next simulation step, the thread waits to send a command in the next tic.</p>
</div>
<div class="section" id="tips">
<h3><span class="section-number">6.2.3. </span>Tips<a class="headerlink" href="#tips" title="Permalink to this headline">¶</a></h3>
<p>Here we collect tips to develop soccer client programs.</p>
<blockquote>
<div><ul class="simple">
<li><p>Debugging is the main problem in developing your own team. So try to find easy
debuging methods.</p></li>
<li><p>A nice and simple way to see your program’s variables in a condition is to use
an <strong>abort()</strong> command or some <strong>asserts</strong> to force the program to core-dump; And
debug the core using gbd.</p></li>
<li><p>Log every message received from the server and sent to the server. It is very useful
for debugging.</p></li>
<li><p>Using ready to use libraries for socket and parsing problems is useful if you are a
beginner.</p></li>
<li><p>Remember to pass the version number to the server in the init command. Although
it is optional, the default is 3.00 which usually is not desired.</p></li>
<li><p>Even if the catch probability is 1.00 your catch command may be unsuccessful
because of errors in returned sensors about the positions.</p></li>
<li><p>The first serious problem you may encounter is the timing problem. There are
many methods to synchronize your client’s time with server. One simple methods
is to use received sense body information.</p></li>
<li><p>Beware of slow networks. If your timing is not very powerful your client’s will
behave abnormaly in a crowded or slow network or if they are out of process
resources (e.g. you run many clients on one slow machine). In this case they may
see older positions and will try to act in these positions and this will result in
confusion (e.g. they will turn around themselves)</p></li>
<li><p>The main usage of flags are for the player to find the position of himself in the field.
Your very first clients may ignore flags and play with relative system of positions.
But you may need a positioning module in the near future. There are many of the
in the ready to use libraries.</p></li>
<li><p>The program should check the end of buffer in analyzing sensor information. The
sensor information uses S-expressions. But the expression may not be completed
when the sensor data is longer than the buffer, so that some closing parentheses are
lost. In this case, the program may core-dump if it parses the expression naively.</p></li>
</ul>
</div></blockquote>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Users can redirect the output to any file or program. For example, you can redirect it to /dev/null
to discard the information by invoking “% client SERVERHOST &gt; /dev/null”. Then, the users can
see the string they type-in.</p>
</dd>
</dl>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. Soccer Client</a><ul>
<li><a class="reference internal" href="#protocols">6.1. Protocols</a><ul>
<li><a class="reference internal" href="#initialization-and-reconnection">6.1.1. Initialization and Reconnection</a><ul>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#reconnection">Reconnection</a></li>
<li><a class="reference internal" href="#disconnection">Disconnection</a></li>
<li><a class="reference internal" href="#version-control">Version Control</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-commands">6.1.2. Control Commands</a><ul>
<li><a class="reference internal" href="#body-commands">Body Commands</a></li>
<li><a class="reference internal" href="#communication-commands">Communication Commands</a></li>
<li><a class="reference internal" href="#misc-commands">Misc. Commands</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sensor-information">6.1.3. Sensor Information</a><ul>
<li><a class="reference internal" href="#visual-sensor">Visual Sensor</a></li>
<li><a class="reference internal" href="#audio-sensor">Audio Sensor</a></li>
<li><a class="reference internal" href="#body-sensor">Body Sensor</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-create-clients">6.2. How to Create Clients</a><ul>
<li><a class="reference internal" href="#sample-client">6.2.1. Sample Client</a><ul>
<li><a class="reference internal" href="#overall-structure-of-sample-client">Overall Structure of Sample Client</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simple-clients">6.2.2. Simple Clients</a></li>
<li><a class="reference internal" href="#tips">6.2.3. Tips</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="soccermonitor.html"
                        title="previous chapter"><span class="section-number">5. </span>Soccer Monitor</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="coach.html"
                        title="next chapter"><span class="section-number">7. </span>Coach</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/soccerclient.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="coach.html" title="7. Coach"
             >next</a> |</li>
        <li class="right" >
          <a href="soccermonitor.html" title="5. Soccer Monitor"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The RoboCup Soccer Simulator  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Soccer Client</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright The RoboCup Soccer Simulator Maintenance Committee.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>